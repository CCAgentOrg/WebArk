<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="theme-color" content="#0d1117">
  <meta name="description" content="Archive web pages to multiple providers">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="WebArk">
  <link rel="manifest" href="/manifest.json">
  <title>üóÑÔ∏è WebArk</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0d1117; color: #c9d1d9; min-height: 100vh; padding: 20px; }
    .container { max-width: 800px; margin: 0 auto; }
    h1 { color: #58a6ff; border-bottom: 2px solid #30363d; padding-bottom: 10px; margin-bottom: 20px; }
    h2 { color: #8b949e; font-size: 14px; margin: 20px 0 10px; text-transform: uppercase; letter-spacing: 1px; }
    textarea, input[type="text"], input[type="number"], select { width: 100%; padding: 12px; background: #161b22; border: 1px solid #30363d; border-radius: 8px; color: #c9d1d9; font-size: 14px; }
    textarea { min-height: 80px; }
    textarea:focus, input:focus, select:focus { outline: none; border-color: #58a6ff; }
    .btn { background: #238636; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; }
    .btn:hover { background: #2ea043; }
    .btn-secondary { background: #30363d; }
    .btn-secondary:hover { background: #484f58; }
    .btn-small { padding: 6px 10px; font-size: 12px; }
    .btn-danger { background: #da3633; }
    .btn-danger:hover { background: #f85149; }
    .btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
    .summary, .url-group, .status-card { background: #161b22; padding: 16px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #30363d; }
    .original-url { color: #e3b341; word-break: break-all; }
    .archive-link { display: block; color: #58a6ff; text-decoration: none; padding: 6px 0; }
    .archive-link:hover { text-decoration: underline; }
    .loading { text-align: center; padding: 40px; }
    .spinner { width: 40px; height: 40px; border: 3px solid #30363d; border-top-color: #58a6ff; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .error { background: #da3633; color: white; padding: 12px; border-radius: 8px; margin-bottom: 16px; }
    .success { background: #238636; color: white; padding: 12px; border-radius: 8px; margin-bottom: 16px; }
    .providers { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
    .provider-btn { background: #21262d; color: #c9d1d9; border: 1px solid #30363d; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; }
    .provider-btn.active { background: #388bfd; color: white; border-color: #388bfd; }
    .provider-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .status-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }
    .status-archived { background: #238636; }
    .status-not-archived { background: #da3633; }
    .status-unknown { background: #d29922; }
    .status-checking { background: #58a6ff; animation: pulse 1s infinite; }
    @keyframes pulse { 50% { opacity: 0.5; } }
    .link-list { max-height: 400px; overflow-y: auto; }
    .link-item { padding: 10px; border-bottom: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .link-item:last-child { border-bottom: none; }
    .link-url { color: #8b949e; font-size: 13px; word-break: break-all; flex: 1; }
    .link-external { color: #f78166; }
    .link-internal { color: #58a6ff; }
    .tab-buttons { display: flex; gap: 4px; margin-bottom: 16px; flex-wrap: wrap; }
    .tab-btn { flex: 1; min-width: 70px; padding: 10px 8px; background: #21262d; border: 1px solid #30363d; color: #8b949e; border-radius: 6px; cursor: pointer; text-align: center; font-size: 13px; }
    .tab-btn.active { background: #388bfd; color: white; border-color: #388bfd; }
    .hidden { display: none; }
    .stats { display: flex; gap: 12px; margin-bottom: 12px; flex-wrap: wrap; }
    .stat { background: #21262d; padding: 10px 14px; border-radius: 6px; text-align: center; }
    .stat-num { font-size: 20px; font-weight: bold; color: #58a6ff; }
    .stat-label { font-size: 11px; color: #8b949e; }
    .table-container { overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #30363d; }
    th { background: #21262d; color: #8b949e; font-weight: 600; font-size: 12px; }
    td { background: #161b22; }
    tr:hover td { background: #21262d; }
    .checkbox-cell { width: 30px; }
    .url-cell { max-width: 300px; word-break: break-all; }
    .checkbox { width: 18px; height: 18px; cursor: pointer; }
    .select-all-btn { font-size: 11px; padding: 4px 8px; }
    .history-item { padding: 12px; border-bottom: 1px solid #30363d; }
    .history-item:last-child { border-bottom: none; }
    .history-url { color: #e3b341; font-size: 13px; word-break: break-all; }
    .history-meta { color: #8b949e; font-size: 11px; margin-top: 4px; }
    .settings-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid #30363d; }
    .settings-row:last-child { border-bottom: none; }
    .settings-label { font-weight: 600; }
    .settings-desc { color: #8b949e; font-size: 12px; }
    .depth-btn { flex: 1; }
    .depth-btn.active { background: #388bfd; color: white; border-color: #388bfd; }
    .action-bar { position: sticky; bottom: 0; background: #0d1117; padding: 12px 0; border-top: 1px solid #30363d; margin-top: 16px; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
    .badge-success { background: #238636; }
    .badge-error { background: #da3633; }
    .badge-warning { background: #d29922; color: #0d1117; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üóÑÔ∏è WebArk</h1>
    
    <div class="tab-buttons">
      <button class="tab-btn" onclick="switchTab('about')">About</button>
      <button class="tab-btn active" onclick="switchTab('archive')">Archive</button>
      <button class="tab-btn" onclick="switchTab('crawl')">Crawl</button>
      <button class="tab-btn" onclick="switchTab('history')">History</button>
      <button class="tab-btn" onclick="switchTab('settings')">Settings</button>
    </div>
    
    <!-- About Tab -->
    <div id="tab-about" class="hidden">
      <div class="summary">
        <h2 style="color:#58a6ff;margin-top:0;">üóÑÔ∏è WebArk</h2>
        <p>A privacy-first, serverless web archiver. Archive pages to multiple providers directly from your browser.</p>
        <p style="margin-top:12px;color:#8b949e;">No server ‚Ä¢ No tracking ‚Ä¢ Works offline via PWA</p>
      </div>
      
      <h2>Features</h2>
      <div class="url-group">
        <p><strong>üì¶ Archive</strong> - Save URLs to Wayback, archive.is, archive.ph</p>
        <p><strong>üîç Check Status</strong> - See which providers have a page archived</p>
        <p><strong>üï∑Ô∏è Crawl</strong> - Find & archive pages at 1-2 depth levels</p>
        <p><strong>üìú History</strong> - Track your archiving activity</p>
        <p><strong>üì± PWA</strong> - Install as app, works offline</p>
      </div>
      
      <h2>How to Use</h2>
      <div class="url-group">
        <p><strong>Archive:</strong> Enter URLs ‚Üí Select provider ‚Üí Click Archive</p>
        <p><strong>Crawl:</strong> Enter URL ‚Üí Set depth ‚Üí Click "Find Links" ‚Üí Check status ‚Üí Archive</p>
      </div>
      
      <h2>Install</h2>
      <div class="url-group">
        <p>Chrome: ‚ãÆ ‚Üí Install WebArk</p>
        <p>Safari: Share ‚Üí Add to Home Screen</p>
        <p>Firefox: ‚ãØ ‚Üí Add to PWA</p>
      </div>
      
      <h2>Source</h2>
      <div class="url-group">
        <p><a href="https://github.com/CCAgentOrg/WebArk" target="_blank" style="color:#58a6ff;">github.com/CCAgentOrg/WebArk</a></p>
      </div>
    </div>
    
    <!-- Archive Tab -->
    <div id="tab-archive">
      <textarea id="urls" placeholder="Enter URLs (one per line)"></textarea>
      <div class="providers">
        <button class="provider-btn active" data-provider="wayback">Wayback</button>
        <button class="provider-btn" data-provider="archiveis">archive.is</button>
        <button class="provider-btn" data-provider="archiveph">archive.ph</button>
        <button class="provider-btn" data-provider="ghostarchive">Ghost</button>
        <button class="provider-btn" data-provider="archivevn">ArchiveVN</button>
        <button class="provider-btn" data-provider="textise">Textise</button>
        <button class="provider-btn" data-provider="memento">Memento</button>
        <button class="provider-btn" data-provider="local">üì± Local</button>
      </div>
      <div class="btn-group">
        <button class="btn" onclick="archive()">Archive URLs</button>
        <button class="btn btn-secondary" onclick="clearResults()">Clear</button>
      </div>
      <div id="archive-results"></div>
    </div>
    
    <!-- Crawl Tab -->
    <div id="tab-crawl" class="hidden">
      <input type="text" id="crawl-url" placeholder="Enter page URL to crawl...">
      
      <h2>Depth</h2>
      <div class="btn-group">
        <button class="btn btn-secondary depth-btn" onclick="setDepth(1)" id="depth-1">1 Level (Page)</button>
        <button class="btn btn-secondary depth-btn active" onclick="setDepth(2)" id="depth-2">2 Levels (Site)</button>
      </div>
      
      <h2>Options</h2>
      <div class="btn-group">
        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
          <input type="checkbox" id="include-external" checked> Include external links
        </label>
        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
          <input type="checkbox" id="skip-top-sites" checked> Skip top sites (Wikipedia, GitHub, etc.)
        </label>
      </div>
      
      <div class="providers">
        <button class="provider-btn active" data-provider="wayback">Wayback</button>
        <button class="provider-btn" data-provider="archiveis">archive.is</button>
        <button class="provider-btn" data-provider="archiveph">archive.ph</button>
        <button class="provider-btn" data-provider="ghostarchive">Ghost</button>
        <button class="provider-btn" data-provider="archivevn">ArchiveVN</button>
        <button class="provider-btn" data-provider="textise">Textise</button>
        <button class="provider-btn" data-provider="memento">Memento</button>
        <button class="provider-btn" data-provider="local">üì± Local</button>
      </div>
      
      <div class="btn-group">
        <button class="btn" onclick="findLinks()">üîç Find Links</button>
        <button class="btn btn-secondary" onclick="checkAllStatus()">‚úÖ Check Status</button>
      </div>
      
      <div id="crawl-stats" class="hidden">
        <div class="stats" id="crawl-stats-inner"></div>
      </div>
      
      <div id="crawl-results"></div>
      
      <div id="crawl-action-bar" class="action-bar hidden">
        <div class="btn-group">
          <button class="btn" onclick="archiveSelected()">üì¶ Archive Selected</button>
          <button class="btn btn-secondary" onclick="archiveUnarchived()">üì¶ Archive Unarchived</button>
          <button class="btn btn-secondary" onclick="archiveAll()">üì¶ Archive All</button>
        </div>
      </div>
    </div>
    
    <!-- History Tab -->
    <div id="tab-history" class="hidden">
      <div class="btn-group">
        <button class="btn btn-secondary btn-small" onclick="clearHistory()">Clear History</button>
      </div>
      <div id="history-list"></div>
    </div>
    
    <!-- Settings Tab -->
    <div id="tab-settings" class="hidden">
      <div class="url-group">
        <div class="settings-row">
          <div>
            <div class="settings-label">Default Provider</div>
            <div class="settings-desc">Provider selected by default</div>
          </div>
          <select id="setting-provider" style="width:150px;" onchange="saveSettings()">
            <option value="wayback">Wayback</option>
            <option value="archiveis">archive.is</option>
            <option value="archiveph">archive.ph</option>
            <option value="ghostarchive">Ghostarchive</option>
            <option value="archivevn">ArchiveVN</option>
            <option value="textise">Textise</option>
            <option value="memento">Memento</option>
            <option value="local">üì± Local</option>
          </select>
        </div>
        
        <div class="settings-row">
          <div>
            <div class="settings-label">Default Depth</div>
            <div class="settings-desc">Crawl depth default</div>
          </div>
          <select id="setting-depth" style="width:150px;" onchange="saveSettings()">
            <option value="1">1 Level</option>
            <option value="2">2 Levels</option>
          </select>
        </div>
        
        <div class="settings-row">
          <div>
            <div class="settings-label">Auto-check Status</div>
            <div class="settings-desc">Automatically check when finding links</div>
          </div>
          <input type="checkbox" id="setting-autocheck" onchange="saveSettings()">
        </div>
        
        <div class="settings-row">
          <div>
            <div class="settings-label">Background Mode</div>
            <div class="settings-desc">Archive without opening popups (where supported)</div>
          </div>
          <input type="checkbox" id="setting-background" onchange="saveSettings()">
        </div>
        
        <div class="settings-row">
          <div>
            <div class="settings-label">Rate Limit (ms)</div>
            <div class="settings-desc">Delay between archive requests</div>
          </div>
          <input type="number" id="setting-rate" value="500" min="100" max="5000" style="width:100px;" onchange="saveSettings()">
        </div>
        
        <div class="settings-row">
          <div>
            <div class="settings-label">Language</div>
            <div class="settings-desc">Select your language</div>
          </div>
          <select id="setting-lang" style="width:150px;" onchange="changeLanguage(this.value)">
            <option value="en">English</option>
            <option value="es">Espa√±ol</option>
            <option value="fr">Fran√ßais</option>
            <option value="de">Deutsch</option>
            <option value="zh">‰∏≠Êñá</option>
            <option value="ja">Êó•Êú¨Ë™û</option>
            <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
            <option value="pt">Portugu√™s</option>
            <option value="ru">–†—É—Å—Å–∫–∏–π</option>
            <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä</option>
            <option value="ta">‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç</option>
            <option value="te">‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å</option>
            <option value="ml">‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç</option>
            <option value="kn">‡≤ï‡≤®‡≥ç‡≤®‡≤°</option>
            <option value="gu">‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä</option>
            <option value="mr">‡§Æ‡§∞‡§æ‡§†‡•Ä</option>
            <option value="bn">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ</option>
            <option value="pa">‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä</option>
            <option value="ur">ÿßÿ±ÿØŸà</option>
            <option value="vi">Ti·∫øng Vi·ªát</option>
            <option value="th">‡πÑ‡∏ó‡∏¢</option>
            <option value="it">Italiano</option>
            <option value="nl">Nederlands</option>
            <option value="pl">Polski</option>
            <option value="tr">T√ºrk√ße</option>
            <option value="sv">Svenska</option>
            <option value="da">Dansk</option>
            <option value="fi">Suomi</option>
            <option value="no">Norsk</option>
            <option value="cs">ƒåe≈°tina</option>
            <option value="el">ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨</option>
            <option value="he">◊¢◊ë◊®◊ô◊™</option>
            <option value="hu">Magyar</option>
            <option value="id">Bahasa Indonesia</option>
            <option value="ms">Bahasa Melayu</option>
            <option value="ro">Rom√¢nƒÉ</option>
            <option value="sk">Slovenƒçina</option>
            <option value="uk">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</option>
            <option value="bg">–ë—ä–ª–≥–∞—Ä—Å–∫–∏</option>
            <option value="ca">Catal√†</option>
            <option value="hr">Hrvatski</option>
            <option value="et">Eesti</option>
            <option value="lv">Latvie≈°u</option>
            <option value="lt">Lietuvi≈≥</option>
            <option value="sr">–°—Ä–ø—Å–∫–∏</option>
            <option value="sl">Sloven≈°ƒçina</option>
            <option value="tl">Filipino</option>
            <option value="fa">ŸÅÿßÿ±ÿ≥€å</option>
            <option value="mr">‡§Æ‡§∞‡§æ‡§†‡•Ä</option>
            <option value="ne">‡§®‡•á‡§™‡§æ‡§≤‡•Ä</option>
            <option value="sw">Kiswahili</option>
            <option value="af">Afrikaans</option>
          </select>
        </div>
      </div>
      
      <div class="btn-group" style="margin-top:20px;">
        <button class="btn btn-danger" onclick="resetSettings()">Reset to Defaults</button>
      </div>
    </div>
    
    <div id="results"></div>
  </div>
  
  <script>
    // ============ CONFIG ============
    // Top sites that are already well-archived - skip by default
    const TOP_SITES = [
      'wikipedia.org', 'wikimedia.org', 'wiktionary.org', 'wikibooks.org', 'wikidata.org',
      'github.com', 'github.io', 'gitlab.com',
      'twitter.com', 'x.com', 't.co',
      'facebook.com', 'fb.com', 'instagram.com', 'threads.net',
      'youtube.com', 'youtu.be', 'yewtu.be',
      'reddit.com', 'old.reddit.com', 'redd.it',
      'linkedin.com',
      'medium.com', 'substack.com',
      'stackoverflow.com', 'stackexchange.com',
      'news.ycombinator.com',
      'nytimes.com', 'theguardian.com', 'bbc.com', 'bbc.co.uk', 'reuters.com', 'apnews.com',
      'cnn.com', 'foxnews.com', 'washingtonpost.com',
      'amazon.com', 'amazon.co.uk', 'amazon.de',
      'google.com', 'google.co.in', 'google.co.uk', 'google.de',
      'microsoft.com', 'apple.com', 'apple.co',
      'reddit.com', 'discord.com', 'slack.com',
      'cloudflare.com', 'fastly.com',
      'letsencrypt.org', 'cacert.org',
      'archive.org', 'web.archive.org',
      'creativecommons.org', 'gnu.org', 'fsf.org',
      'w3.org', 'ietf.org', 'mdn.io',
      'npmjs.com', 'pypi.org', 'rubygems.org', 'crates.io',
      'wordpress.com', 'blogspot.com', 'tumblr.com',
      'youtu.be', 'vimeo.com', 'dailymotion.com',
      'dropbox.com', 'drive.google.com', 'onedrive.live.com',
      'zoom.us', 'meet.google.com',
      'bit.ly', 'tinyurl.com', 'goo.gl', 'ow.ly', 't.co',
      'feedburner.com', 'feeds.feedburner.com'
    ];
    
    // Check if domain should be skipped
    function shouldSkipDomain(url) {
      try {
        const domain = new URL(url).hostname.toLowerCase();
        return TOP_SITES.some(site => domain === site || domain.endsWith('.' + site));
      } catch { return false; }
    }
  </script>
  
  <script src="/js/translations.js"></script>
  <script src="/js/providers.js"></script>
  
  <script>
    // ============ LOCAL ARCHIVE ============
    const DB_NAME = 'webark-archives';
    const STORE_NAME = 'archives';
    
    async function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'url' });
          }
        };
      });
    }
    
    async function archiveLocally(url) {
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        
        // Fetch the page
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
        const res = await fetch(proxyUrl);
        const data = await res.json();
        
        if (!data.contents) {
          return { success: false, error: 'Failed to fetch page' };
        }
        
        // Parse and inline resources
        let html = data.contents;
        
        // Extract base URL for relative links
        const baseUrl = new URL(url);
        
        // Inline images (convert to data URLs where possible - limited)
        // For now, just store the HTML with adjusted links
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Update links to be absolute
        doc.querySelectorAll('a[href]').forEach(a => {
          try {
            a.href = new URL(a.getAttribute('href'), baseUrl).href;
          } catch {}
        });
        
        // Update images to use absolute URLs (can't inline easily without CORS)
        doc.querySelectorAll('img[src]').forEach(img => {
          try {
            img.src = new URL(img.getAttribute('src'), baseUrl).href;
          } catch {}
        });
        
        // Get final HTML
        html = '<!DOCTYPE html>\n<html>\n<head>\n';
        html += `<meta charset="utf-8">\n`;
        html += `<meta name="webark-original-url" content="${url}">\n`;
        html += `<meta name="webark-archived-at" content="${new Date().toISOString()}">\n`;
        html += '</head>\n<body>\n';
        html += `<!-- Original URL: ${url} -->\n`;
        html += `<!-- Archived: ${new Date().toISOString()} -->\n`;
        html += doc.body.innerHTML;
        html += '\n</body>\n</html>';
        
        // Save to IndexedDB
        const archiveData = {
          url: url,
          archivedUrl: url,
          html: html,
          title: doc.title || url,
          archivedAt: new Date().toISOString(),
          size: html.length
        };
        
        store.put(archiveData);
        
        await new Promise((resolve, reject) => {
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        });
        
        return { success: true, archivedUrl: 'üì± Saved to local storage' };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }
    
    async function checkLocalArchive(url) {
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        
        return new Promise((resolve) => {
          const request = store.get(url);
          request.onsuccess = () => {
            if (request.result) {
              resolve(url + ' (local)'); // Return URL if archived
            } else {
              resolve(null);
            }
          };
          request.onerror = () => resolve(null);
        });
      } catch {
        return null;
      }
    }
    
    async function getLocalArchives() {
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        
        return new Promise((resolve) => {
          const request = store.getAll();
          request.onsuccess = () => resolve(request.result || []);
          request.onerror = () => resolve([]);
        });
      } catch {
        return [];
      }
    }
    
    async function deleteLocalArchive(url) {
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.delete(url);
        
        await new Promise((resolve) => {
          tx.oncomplete = resolve;
        });
        return true;
      } catch {
        return false;
      }
    }
    
    // ============ STATE ============
    let selectedProvider = 'wayback';
    let crawlDepth = 2;
    let crawlLinks = [];
    let settings = {};
    
    // ============ INIT ============
    function init() {
      loadSettings();
      loadHistory();
      restoreTab();
    }
    
    function loadSettings() {
      const saved = localStorage.getItem('webark-settings');
      settings = saved ? JSON.parse(saved) : {
        provider: 'wayback',
        depth: 2,
        autoCheck: false,
        backgroundMode: true,
        rateLimit: 500
      };
      
      document.getElementById('setting-provider').value = settings.provider;
      document.getElementById('setting-depth').value = settings.depth;
      document.getElementById('setting-autocheck').checked = settings.autoCheck;
      document.getElementById('setting-background').checked = settings.backgroundMode;
      document.getElementById('setting-rate').value = settings.rateLimit;
      
      // Load language
      currentLang = localStorage.getItem('webark-lang') || 'en';
      document.getElementById('setting-lang').value = currentLang;
      applyTranslations();
      
      selectedProvider = settings.provider;
      crawlDepth = settings.depth;
      
      // Update UI
      document.querySelectorAll('.provider-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.provider === selectedProvider);
      });
      document.querySelectorAll('.depth-btn').forEach(btn => {
        btn.classList.toggle('active', btn.id === 'depth-' + crawlDepth);
      });
    }
    
    function saveSettings() {
      settings = {
        provider: document.getElementById('setting-provider').value,
        depth: parseInt(document.getElementById('setting-depth').value),
        autoCheck: document.getElementById('setting-autocheck').checked,
        backgroundMode: document.getElementById('setting-background').checked,
        rateLimit: parseInt(document.getElementById('setting-rate').value)
      };
      localStorage.setItem('webark-settings', JSON.stringify(settings));
    }
    
    function changeLanguage(lang) {
      setLanguage(lang);
    }
    
    function resetSettings() {
      localStorage.removeItem('webark-settings');
      loadSettings();
    }
    
    // ============ UI ============
    function switchTab(tab) {
      localStorage.setItem('webark-last-tab', tab);
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('[id^="tab-"]').forEach(d => d.classList.add('hidden'));
      event?.target?.classList.add('active');
      document.getElementById('tab-' + tab).classList.remove('hidden');
      
      if (tab === 'history') loadHistory();
    }
    
    function restoreTab() {
      const last = localStorage.getItem('webark-last-tab') || 'archive';
      document.querySelector(`[onclick="switchTab('${last}')"]`)?.click();
    }
    
    document.querySelectorAll('.provider-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.provider-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedProvider = btn.dataset.provider;
      });
    });
    
    function setDepth(depth) {
      crawlDepth = depth;
      document.querySelectorAll('.depth-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('depth-' + depth).classList.add('active');
    }
    
    // ============ ARCHIVE ============
    async function archive() {
      const urls = document.getElementById('urls').value.split('\n').map(u => u.trim()).filter(u => u);
      if (!urls.length) return alert('Enter URLs');
      
      const provider = providers[selectedProvider];
      const resultsDiv = document.getElementById('archive-results');
      const useBackground = settings.backgroundMode && provider.backgroundArchive;
      
      if (useBackground) {
        resultsDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Archiving in background...</div>';
        
        let success = 0;
        let failed = 0;
        const rate = settings.rateLimit || 500;
        
        for (const url of urls) {
          const result = await provider.backgroundArchive(url);
          if (result.success) {
            success++;
            addToHistory(url, 'archive', selectedProvider);
          } else {
            failed++;
          }
          await new Promise(r => setTimeout(r, rate));
        }
        
        resultsDiv.innerHTML = `<div class="success">Archived ${success} URL(s)${failed > 0 ? ', ' + failed + ' failed' : ''}</div>`;
      } else {
        // Fallback to popups
        resultsDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Opening archive pages...</div>';
        
        let opened = 0;
        for (const url of urls) {
          window.open(provider.archiveUrl(url), '_blank');
          addToHistory(url, 'archive', selectedProvider);
          opened++;
          await new Promise(r => setTimeout(r, settings.rateLimit || 500));
        }
        
        resultsDiv.innerHTML = '<div class="success">Opened ' + opened + ' archive pages!</div>';
      }
    }
    
    function clearResults() {
      document.getElementById('urls').value = '';
      document.getElementById('archive-results').innerHTML = '';
    }
    
    // ============ CRAWL ============
    async function findLinks() {
      const url = document.getElementById('crawl-url').value.trim();
      if (!url) return alert('Enter a URL');
      
      // Validate URL
      try {
        new URL(url);
      } catch {
        return alert('Invalid URL');
      }
      
      const resultsDiv = document.getElementById('crawl-results');
      resultsDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Finding links...</div>';
      
      const baseUrl = new URL(url);
      const includeExternal = document.getElementById('include-external').checked;
      const skipTopSites = document.getElementById('skip-top-sites')?.checked ?? true;
      
      // Always add the base URL first
      const links = new Map();
      links.set(normalizeUrl(url), { url: url, internal: true, status: 'unknown' });
      
      if (crawlDepth > 1) {
        // Try Wayback CDX API with proper parameters
        try {
          const domain = baseUrl.hostname;
          const res = await fetch(
            `https://web.archive.org/cdx/search/cdx?url=${encodeURIComponent(domain + '/*')}&output=json&fl=original&filter=statuscode:200&limit=300`
          );
          const data = await res.json();
          
          if (data && data.length > 1) {
            for (let i = 1; i < data.length; i++) {
              const originalUrl = data[i][0];
              if (originalUrl && isValidUrl(originalUrl)) {
                const normalized = normalizeUrl(originalUrl);
                const linkUrl = new URL(normalized);
                const isInternal = linkUrl.hostname === baseUrl.hostname;
                
                if ((isInternal || includeExternal) && !normalized.match(/\.(jpg|png|gif|css|js|woff|svg|pdf|zip)$/i) && !(skipTopSites && shouldSkipDomain(normalized))) {
                  if (!links.has(normalized)) {
                    links.set(normalized, { url: normalized, internal: isInternal, status: 'unknown' });
                  }
                }
              }
            }
          }
        } catch (e) {
          console.error('Wayback CDX error:', e);
        }
        
        // If we got limited results, try page extraction
        if (links.size < 5) {
          try {
            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
            const res = await fetch(proxyUrl);
            const data = await res.json();
            
            if (data.contents) {
              const parser = new DOMParser();
              const doc = parser.parseFromString(data.contents, 'text/html');
              const anchors = doc.querySelectorAll('a[href]');
              
              for (const anchor of anchors) {
                try {
                  const href = anchor.getAttribute('href');
                  if (!href) continue;
                  
                  let fullUrl;
                  try {
                    fullUrl = new URL(href, baseUrl).href;
                  } catch { continue; }
                  
                  if (!fullUrl.startsWith('http') || fullUrl.match(/\.(jpg|png|gif|css|js|woff|svg|pdf|zip)$/i)) continue;
                  
                  const normalized = normalizeUrl(fullUrl);
                  const linkUrl = new URL(normalized);
                  const isInternal = linkUrl.hostname === baseUrl.hostname;
                  
                  if ((isInternal || includeExternal) && !links.has(normalized) && !(skipTopSites && shouldSkipDomain(normalized))) {
                    links.set(normalized, { url: normalized, internal: isInternal, status: 'unknown' });
                  }
                } catch {}
              }
            }
          } catch (e) {
            console.error('Page extraction error:', e);
          }
        }
      }
      
      crawlLinks = Array.from(links.values()).slice(0, 100);
      renderCrawlTable();
      
      // Auto check if enabled
      if (settings.autoCheck) {
        setTimeout(() => checkAllStatus(), 500);
      }
    }
    
    // Helper functions
    function isValidUrl(str) {
      try {
        const u = new URL(str);
        return u.protocol === 'http:' || u.protocol === 'https:';
      } catch { return false; }
    }
    
    function normalizeUrl(url) {
      try {
        const u = new URL(url);
        u.hash = '';
        if ((u.protocol === 'http:' && u.port === '80') || (u.protocol === 'https:' && u.port === '443')) {
          u.port = '';
        }
        return u.href.replace(/\/$/, '');
      } catch { return url; }
    }
    
    function renderCrawlTable() {
      const resultsDiv = document.getElementById('crawl-results');
      const statsDiv = document.getElementById('crawl-stats');
      const actionBar = document.getElementById('crawl-action-bar');
      
      const internal = crawlLinks.filter(l => l.internal).length;
      const external = crawlLinks.filter(l => !l.internal).length;
      const archived = crawlLinks.filter(l => l.status === 'archived').length;
      
      statsDiv.classList.remove('hidden');
      statsDiv.innerHTML = `
        <div class="stat"><div class="stat-num">${crawlLinks.length}</div><div class="stat-label">Total Links</div></div>
        <div class="stat"><div class="stat-num">${internal}</div><div class="stat-label">Internal</div></div>
        <div class="stat"><div class="stat-num">${external}</div><div class="stat-label">External</div></div>
        <div class="stat"><div class="stat-num">${archived}</div><div class="stat-label">Archived</div></div>
      `;
      
      if (crawlLinks.length === 0) {
        resultsDiv.innerHTML = '<div class="summary">No links found. Try a different URL.</div>';
        actionBar.classList.add('hidden');
        return;
      }
      
      let html = `
        <div class="table-container">
          <table>
            <thead>
              <tr>
                <th class="checkbox-cell"><input type="checkbox" class="checkbox" onchange="toggleAll(this)"></th>
                <th>URL</th>
                <th>Type</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      for (const link of crawlLinks) {
        const statusClass = link.status === 'archived' ? 'status-archived' : (link.status === 'checking' ? 'status-checking' : 'status-not-archived');
        const statusText = link.status === 'archived' ? 'Archived' : (link.status === 'checking' ? 'Checking...' : 'Not archived');
        const typeClass = link.internal ? 'link-internal' : 'link-external';
        const typeText = link.internal ? 'Internal' : 'External';
        
        html += `
          <tr>
            <td class="checkbox-cell"><input type="checkbox" class="checkbox link-checkbox" data-url="${encodeURIComponent(link.url)}"></td>
            <td class="url-cell">${link.url.substring(0, 80)}${link.url.length > 80 ? '...' : ''}</td>
            <td><span class="${typeClass}">${typeText}</span></td>
            <td><span class="status-indicator ${statusClass}"></span>${statusText}</td>
          </tr>
        `;
      }
      
      html += '</tbody></table></div>';
      resultsDiv.innerHTML = html;
      actionBar.classList.remove('hidden');
    }
    
    function toggleAll(source) {
      document.querySelectorAll('.link-checkbox').forEach(cb => cb.checked = source.checked);
    }
    
    async function checkAllStatus() {
      const provider = providers[selectedProvider];
      
      // Show checking state
      crawlLinks.forEach(l => l.status = 'checking');
      renderCrawlTable();
      
      for (let i = 0; i < crawlLinks.length; i++) {
        const link = crawlLinks[i];
        link.status = 'checking';
        
        // Update single row
        const checkboxes = document.querySelectorAll('.link-checkbox');
        if (checkboxes[i]) {
          const row = checkboxes[i].closest('tr');
          row.querySelector('.status-indicator').className = 'status-indicator status-checking';
          row.querySelector('td:last-child').innerHTML = '<span class="status-indicator status-checking"></span>Checking...';
        }
        
        const archivedUrl = await provider.checkArchived(link.url);
        link.status = archivedUrl ? 'archived' : 'not-archived';
        link.archivedUrl = archivedUrl;
        
        // Update row
        if (checkboxes[i]) {
          const row = checkboxes[i].closest('tr');
          const statusClass = archivedUrl ? 'status-archived' : 'status-not-archived';
          const statusText = archivedUrl ? 'Archived' : 'Not archived';
          row.querySelector('.status-indicator').className = 'status-indicator ' + statusClass;
          row.querySelector('td:last-child').innerHTML = '<span class="status-indicator ' + statusClass + '"></span>' + statusText;
        }
        
        await new Promise(r => setTimeout(r, 100)); // Rate limit
      }
      
      // Update stats
      const archived = crawlLinks.filter(l => l.status === 'archived').length;
      const statsDiv = document.getElementById('crawl-stats-inner');
      statsDiv.innerHTML = `
        <div class="stat"><div class="stat-num">${crawlLinks.length}</div><div class="stat-label">Total</div></div>
        <div class="stat"><div class="stat-num">${archived}</div><div class="stat-label">Archived</div></div>
        <div class="stat"><div class="stat-num">${crawlLinks.length - archived}</div><div class="stat-label">Need Archive</div></div>
      `;
    }
    
    async function archiveAll() {
      const provider = providers[selectedProvider];
      const useBackground = settings.backgroundMode && provider.backgroundArchive;
      const rate = settings.rateLimit || 500;
      
      if (useBackground) {
        document.getElementById('crawl-results').innerHTML = '<div class="loading"><div class="spinner"></div>Archiving...</div>';
        
        let success = 0;
        for (const link of crawlLinks) {
          const result = await provider.backgroundArchive(link.url);
          if (result.success) {
            success++;
            addToHistory(link.url, 'archive', selectedProvider);
          }
          await new Promise(r => setTimeout(r, rate));
        }
        
        document.getElementById('crawl-results').innerHTML = '<div class="success">Archived ' + success + ' URLs!</div>';
      } else {
        crawlLinks.forEach((link, i) => {
          setTimeout(() => {
            window.open(provider.archiveUrl(link.url), '_blank');
            addToHistory(link.url, 'archive', selectedProvider);
          }, i * rate);
        });
        
        document.getElementById('crawl-results').innerHTML = '<div class="success">Opened ' + crawlLinks.length + ' archive pages!</div>';
      }
    }
    
    async function archiveUnarchived() {
      const unarchived = crawlLinks.filter(l => l.status !== 'archived');
      const provider = providers[selectedProvider];
      const useBackground = settings.backgroundMode && provider.backgroundArchive;
      const rate = settings.rateLimit || 500;
      
      if (useBackground) {
        document.getElementById('crawl-results').innerHTML = '<div class="loading"><div class="spinner"></div>Archiving...</div>';
        
        let success = 0;
        for (const link of unarchived) {
          const result = await provider.backgroundArchive(link.url);
          if (result.success) {
            success++;
            addToHistory(link.url, 'archive', selectedProvider);
          }
          await new Promise(r => setTimeout(r, rate));
        }
        
        document.getElementById('crawl-results').innerHTML = '<div class="success">Archived ' + success + ' URLs!</div>';
      } else {
        unarchived.forEach((link, i) => {
          setTimeout(() => {
            window.open(provider.archiveUrl(link.url), '_blank');
            addToHistory(link.url, 'archive', selectedProvider);
          }, i * rate);
        });
        
        document.getElementById('crawl-results').innerHTML = '<div class="success">Opened ' + unarchived.length + ' archive pages!</div>';
      }
    }
    
    async function archiveSelected() {
      const checkboxes = document.querySelectorAll('.link-checkbox:checked');
      const selected = Array.from(checkboxes).map(cb => decodeURIComponent(cb.dataset.url));
      
      if (selected.length === 0) return alert('Select links to archive');
      
      const provider = providers[selectedProvider];
      const useBackground = settings.backgroundMode && provider.backgroundArchive;
      const rate = settings.rateLimit || 500;
      
      if (useBackground) {
        document.getElementById('crawl-results').innerHTML = '<div class="loading"><div class="spinner"></div>Archiving...</div>';
        
        let success = 0;
        for (const url of selected) {
          const result = await provider.backgroundArchive(url);
          if (result.success) {
            success++;
            addToHistory(url, 'archive', selectedProvider);
          }
          await new Promise(r => setTimeout(r, rate));
        }
        
        document.getElementById('crawl-results').innerHTML = '<div class="success">Archived ' + success + ' URLs!</div>';
      } else {
        selected.forEach((url, i) => {
          setTimeout(() => {
            window.open(provider.archiveUrl(url), '_blank');
            addToHistory(url, 'archive', selectedProvider);
          }, i * rate);
        });
        
        document.getElementById('crawl-results').innerHTML = '<div class="success">Opened ' + selected.length + ' archive pages!</div>';
      }
    }
    
    // ============ HISTORY ============
    function addToHistory(url, action, provider) {
      const history = JSON.parse(localStorage.getItem('webark-history') || '[]');
      history.unshift({
        url,
        action,
        provider,
        timestamp: new Date().toISOString()
      });
      // Keep last 100
      localStorage.setItem('webark-history', JSON.stringify(history.slice(0, 100)));
    }
    
    async function loadHistory() {
      const history = JSON.parse(localStorage.getItem('webark-history') || '[]');
      const listDiv = document.getElementById('history-list');
      
      // Get local archives
      const localArchives = await getLocalArchives();
      
      let html = '';
      
      // Local archives section
      if (localArchives.length > 0) {
        html += '<h2 style="margin-top:0;">üì± Local Archives</h2>';
        for (const archive of localArchives) {
          const date = new Date(archive.archivedAt);
          const timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const sizeStr = formatSize(archive.size);
          
          html += `
            <div class="history-item">
              <div class="history-url">${archive.title || archive.url}</div>
              <div class="history-meta">
                <span class="badge badge-success">üì± Local</span>
                ${timeStr} ‚Ä¢ ${sizeStr}
                <button class="btn btn-small btn-secondary" onclick="viewLocalArchive('${encodeURIComponent(archive.url)}')">View</button>
                <button class="btn btn-small btn-danger" onclick="deleteLocal('${encodeURIComponent(archive.url)}')">Delete</button>
              </div>
            </div>
          `;
        }
      }
      
      // History section
      if (history.length > 0) {
        html += '<h2 style="margin-top:20px;">üìú History</h2>';
        for (const item of history) {
          const date = new Date(item.timestamp);
          const timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          
          html += `
            <div class="history-item">
              <div class="history-url">${item.url}</div>
              <div class="history-meta">
                <span class="badge badge-success">${item.action}</span>
                via ${providers[item.provider]?.name || item.provider} ‚Ä¢ ${timeStr}
              </div>
            </div>
          `;
        }
      }
      
      if (!html) {
        html = '<div class="summary">No history yet. Start archiving!</div>';
      }
      
      listDiv.innerHTML = html;
    }
    
    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    
    function viewLocalArchive(url) {
      url = decodeURIComponent(url);
      getLocalArchives().then(archives => {
        const archive = archives.find(a => a.url === url);
        if (archive) {
          // Open in new window
          const win = window.open('', '_blank');
          win.document.write(archive.html);
          win.document.close();
        }
      });
    }
    
    async function deleteLocal(url) {
      url = decodeURIComponent(url);
      if (confirm('Delete this local archive?')) {
        await deleteLocalArchive(url);
        loadHistory();
      }
    }
    
    function clearHistory() {
      if (confirm('Clear all history?')) {
        localStorage.removeItem('webark-history');
        loadHistory();
      }
    }
    
    // ============ SERVICE WORKER ============
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js');
    }
    
    init();
  </script>
</body>
</html>
